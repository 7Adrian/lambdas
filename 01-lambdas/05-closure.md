<!-- .slide: data-background="#111111" -->

# Closure

___

## What is underneath lambda?

Every lambda expression cause the compiler to create unique closure class that implements function operator with code from the expression.
<!-- .element: class="fragment fade-in" -->

Closure is an object of closure class. According to way of capture type this object keeps references or copies of local variables.
<!-- .element: class="fragment fade-in" -->

Closures are to lambdas as objects are to classes.
<!-- .element: class="fragment fade-in" -->

[Lambdas vs. Closures by Scott Meyers](http://scottmeyers.blogspot.com/2013/05/lambdas-vs-closures.html)
<!-- .element: class="fragment fade-in" -->

___

```cpp
auto lambda = [scale, &counter, divider = 100u](int x, int y) {
    return (x + y + counter++) * scale / divider;
};
```

```cpp
struct UnnamedClosureClass { // code generated by the compiler
    UnnamedClosureClass(double _scale, int& _counter)
        : scale(_scale), counter(_counter), divider(100u)
    {}

    inline auto operator()(int x, int y) const {
        return (x + y + counter++) * scale / divider;
    }

private:
    const double scale;     // implicit const
    int& counter;
    const unsigned divider; // implicit const
};

auto lambda = UnnamedClosureClass{scale, counter};
```
<!-- .element: class="fragment fade-in" -->
