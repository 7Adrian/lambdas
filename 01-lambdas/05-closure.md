<!-- .slide: data-background="#111111" -->

# Domknięcie

## ang. closure

___

## Co siedzi pod spodem lambdy?

Każde wyrażenie lambda powoduje, że kompilator tworzy unikatową klasę domknięcia, która implementuje operator wywołania z kodem z wyrażenia lambda
<!-- .element: class="fragment fade-in" -->

Domknięcie (closure) jest obiektem klasy domknięcia (closure class). W zależności od tego jak lambda przechwytuje obiekty, ta klasa zawiera kopie lub referencje do zmiennych lokalnych.
<!-- .element: class="fragment fade-in" -->

Domknięcia są względem lambd tym, czym są obiekty względem klas.
<!-- .element: class="fragment fade-in" -->

[Lambdas vs. Closures by Scott Meyers](http://scottmeyers.blogspot.com/2013/05/lambdas-vs-closures.html)
<!-- .element: class="fragment fade-in" -->

___

```cpp
auto lambda = [scale, &counter, divider = 100u](int x, int y) {
    return (x + y + counter++) * scale / divider;
};
```

```cpp
struct UnnamedClosureClass { // code generated by the compiler
    UnnamedClosureClass(double& _scale, int& _counter, const unsigned& _divider)
        : scale(_scale), counter(_counter), divider(_divider)
    {}

    inline auto operator()(int x, int y) const {
        return (x + y + counter++) * scale / divider;
    }

private:
    double scale;
    int& counter;
    unsigned divider;
};

auto lambda = UnnamedClosureClass{scale, counter, 100u};
```
<!-- .element: class="fragment fade-in" -->
