<!-- .slide: data-background="#111111" -->

# Closure

___

## What is underneath lambda?

Every lambda expression cause the compiler to create unique closure class that implements function operator with code from the expression.
<!-- .element: class="fragment fade-in" -->

Closure is an object of closure class. According to way of capture type this object keeps references or copies of local variables.
<!-- .element: class="fragment fade-in" -->

___

```cpp
auto foo(int x, int y) {
    double scale = 10.0;
    int counter = 0;

    auto lambda = [scale, &counter, divider = 100u](int x, int y) {
        return (x + y + counter++) * scale / divider;
    };

    return lambda;
}
```

```cpp
auto foo(int x, int y) {
    double scale = 10.0;
    int counter = 0;

    struct UnnamedClosureClass { // code generated by the compiler for above 1 line
        UnnamedClosureClass(double _scale, int& _counter)
            : scale(_scale), counter(_counter), divider(100u)
        {}

        inline auto operator()(int x, int y) const {
            return (x + y + counter++) * scale / divider;
        }

    private:
        const double scale;     // implicit const
        int& counter;
        const unsigned divider; // implicit const
    };

    auto lambda = UnnamedClosureClass{scale, counter};
    return lambda;
}
```

### What kind of danger can you see in above code snippet?

Dangling reference. It causes undefined behavior.

___