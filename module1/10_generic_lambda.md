<!-- .slide: data-background="#111111" -->

# Generic lambda

___

## Generyczne lambdy

* Od C++14 możemy pisać tzw. generyczne lambdy
* Są to lambdy wielokrotnego użytku (dla różnych typów) i używamy w nich typu `auto` jako parametru
  * `[](const auto first, const auto& second, auto third) {}`
* Pisanie generycznych lambd jest opłacalne, ponieważ łatwo można je wielokrotnie wykorzystać

```cpp
int multiply(int first, int second) {
    return first * second;
}

int main() {
    int number = 10;
    auto multiplyByX = [&number](auto num) { return multiply(num, number); };
    std::cout << multiplyByX(20) << '\n';

    return 0;
}
```

___
<!-- .slide: style="font-size: 0.95em" -->

## Generic lambdas (C++14)

In C++11 parameters of lambda expression must be declared with use of specific type.

C++14 allows to declare parameter as `auto`.

This allows a compiler to deduce the type of lambda parameter in the same way parameters of the templates are deduced. In result compiler generates a code equivalent to closure class given below:

```c++
auto lambda = [](auto x, auto y) { return x + y; }

struct UnnamedClosureClass {// code generated by the compiler for above 1 line
    template <typename T1, typename T2>
    auto operator()(T1 x, T2 y) const {
        return x + y;
    }
};
auto lambda = UnnamedClosureClass();
```

___
